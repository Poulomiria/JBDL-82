Quick recap
The class discussed the creation of custom exceptions in Java, the hierarchy of exception handling, and the use of try-with-resources statements. They also explored the handling of exceptions in Java streams and lambda functions, and the sorting of a list of employees based on their salary and name. Lastly, they addressed various Java programming concepts and issues, including bugs related to integer comparison, the difference between "==" and ".equals()" for comparison, and the behavior of exception handling and stack trace printing in different Java versions and JVMs.  
Next steps
Students to practice exception handling concepts covered in class.
Students to attempt stream assignments, particularly question 8 on finding top 3 employees.
Students to review and understand try-with-resources concept.
Students to explore file handling on their own before next class.
Piyush to push updated code to Github for students to access.
Piyush to review remaining student assignments.
Piyush to add more assignments for students to practice.
Students to prepare for multi-threading and file handling topics for next week's class.
Students to check Java version-specific behavior of exception handling in their development environments.
  Summary
 Creating Custom Exceptions in Java
The class discusses creating custom exceptions in Java, both checked and unchecked. The instructor demonstrates how to create custom exceptions by extending the Exception class for checked exceptions and RuntimeException for unchecked exceptions. They explain the importance of passing messages to the parent constructor using super() to ensure the message is properly associated with the exception. The class also covers how to handle different types of exceptions using multiple catch blocks or nested if-else statements within a single catch block. The instructor emphasizes that creating custom exceptions allows for more specific error handling in large codebases.
Exception Handling in Programming Hierarchy
Class discussed the hierarchy of exception handling in programming, emphasizing the need to handle exceptions at every level of the hierarchy. Rishav suggested the possibility of suppressing exceptions at any level, but Class clarified that exceptions must be handled, either by suppressing or throwing them back. They also discussed the logical sense of the code and the importance of not suppressing important exceptions. Class then introduced the concept of "try with resources" to reduce the need for a separate finally block in exception handling.
Auto Closeable Interface and Try-With-Resources
In the meeting, Class explained the concept of auto closeable interface and its implementation in the context of try-with-resources statements. He clarified that auto closeable is a functional interface with only one abstract function, close, and it is indirectly implemented by classes like FileInputSteam. He also discussed the benefits of using try-with-resources, which automatically calls the close function present inside the class, eliminating the need for manual resource cleanup in the finally block. Rishav and others participated in the discussion, asking questions and seeking clarification on the topic.
  Java Try-With-Resources Statement Overview
In the meeting, Class explained the concept of using resources in Java, specifically focusing on the try-with-resources statement. He demonstrated how to use a custom class, "MyCursor", which implements the AutoCloseable interface, within a try-with-resources block. He highlighted that the try-with-resources statement automatically handles the closing of resources, eliminating the need for a separate finally block. Class also discussed the importance of handling exceptions thrown by the resources, such as the custom exception thrown by the "MyCursor" class. He concluded by emphasizing that the try-with-resources statement is a useful tool for managing resources in Java.
Exception Handling in Cursor Functions
In the meeting, Class discussed the handling of exceptions in the draw and close functions of a cursor object. It was clarified that the draw function only handles exceptions thrown by itself, while the close function also handles any exceptions thrown from the finally block. The team also explored the behavior of try-with-resources, which calls the close function first and then the catch block if an exception occurs. The conversation ended with a discussion on the differences between try-catch-finally and try-with-resources.
  Try-With-Resources and Exception Handling
In the meeting, the team discussed the concept of try-with-resources, a feature in Java that automatically closes resources after use. They debated whether it's necessary to use this feature, with some arguing it's not mandatory and others suggesting it's beneficial for code quality. The team also discussed the importance of understanding exceptions and how to handle them properly. They touched on the topic of atomicity in file transfers, with one team member asking if try-with-resources could ensure atomicity. The team agreed that while try-with-resources could be used to delete file contents in case of an exception, the actual deletion would need to be done in the catch block, not the close or finally block.
  Overriding Methods in Subclasses
In the meeting, Class discussed the concept of overriding methods in a subclass. They clarified that only unchecked exceptions are allowed to be thrown in a subclass if the parent class method does not throw any exception. This is because if the parent class does not throw an exception, the child class cannot throw a checked exception. They also explained that if the child class throws a custom exception, it can create ambiguity and the compiler will not mandate the handling of that exception. They concluded that only runtime exceptions are allowed in such cases. The discussion also touched upon the importance of this concept in job interviews, particularly for Java back-end developers.
  Exception Handling in Java Streams
The class discusses exception handling in Java, focusing on try-with-resources and its differences from traditional try-catch-finally blocks. They explain that try-with-resources automatically handles closing resources, reducing the need for explicit close functions. The discussion then shifts to exception handling in Java streams, where it's noted that stream methods themselves don't throw exceptions. The class demonstrates this with an example of normalizing city name lengths, showing how arithmetic exceptions can occur and how they are handled within streams.
  Java Exception Handling in Streams
In the meeting, Class discussed handling exceptions in Java code, particularly in the context of streams and lambda functions. He explained that checked exceptions, such as IOException, need to be handled using try-catch blocks within the lambda function, rather than being thrown to the calling function. He also clarified that in interviews, the focus is on logic and coding skills rather than exception handling semantics. Class also emphasized the importance of understanding Java collections for coding questions in interviews.
  Sorting Employees by Salary and Name
In the meeting, Class explained how to sort a list of employees based on their salary and name. If two employees have the same salary, they will be sorted alphabetically in ascending order. Class demonstrated this using a code example, showing how to implement the sorting logic. They also discussed the possibility of sorting employees based on other attributes like age if needed.
  Java Programming Concepts and Exceptions
The class discusses several Java programming concepts and issues. The instructor explains a bug related to comparing integers and the difference between using "==" and ".equals()" for comparison. They also address whether stack overflow and out-of-memory errors can be caught in Java, explaining that these are errors, not exceptions, and thus cannot be handled. The class explores the behavior of exception handling and stack trace printing in different Java versions and JVMs, noting that the order of output can vary. The instructor mentions upcoming topics for the next week, including multi-threading and file handling. Students ask questions about logging exceptions and variable overriding in parent and child classes, with the instructor providing explanations and clarifications.  
AI can make mistakes. Review for accuracy.
