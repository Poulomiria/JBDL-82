Quick recap
The instructor introduced a major project on e-wallet development following microservice architecture, explaining three main services and their functionalities while discussing the benefits of microservices over monolithic architecture. The class explored creating multiple independent microservices in a single project using Spring Boot and Maven, including setting up project dependencies and implementing a user service with Kafka integration. The team encountered and resolved various technical issues related to database setup and Kafka configuration, while discussing consumer groups and offset management for message handling.
Next steps
- Development team: Create three microservices: User Service, Wallet Service, and Transaction Service
- Development team: Set up independent databases for each microservice
- Development team: Implement Kafka for service-to-service communication, particularly for user onboarding events
- Development team: Implement user onboarding functionality in User Service
- Development team: Implement Kafka event publishing from User Service for user creation events
- Development team: Implement wallet creation functionality in Wallet Service with configurable promotional balance
- Development team: Implement consumer in Wallet Service to listen for user creation events
- Development team: Implement the transaction service as a separate module
- Development team: Set up Redis cache for user sessions as a fallback mechanism when user service is down
- Team: Organize dependencies in the parent pom.xml to avoid redundancy across modules
- Team: Use Maven clean install to properly manage local repository dependencies
- Team: Implement validation for input data by adding Spring Boot starter validation
- Team: Handle null pointer checks in the user creation process
- Team: Resolve the issue with storing JSON data in the phone/contact field
- Team: Verify that messages are properly published to the Kafka topic
- Development team: Consider adding security/authentication features if time permits
- Development team: Consider adding authentication for transaction operations if time permits
- Class: Push the code for incorporating Redis caching with the database in the minor project
- Class: Allocate 30-45 minutes to complete the Redis caching implementation after finishing the transaction service
- Team: Complete the major project by the next class session
Summary
E-Wallet Microservice Project Overview
The instructor introduced a major project on e-wallet development, explaining it will be completed in two classes and will follow microservice architecture. They outlined three main services: User Service, which handles user account management; Wallet Service, responsible for wallet balance operations; and Transaction Service, which manages money transfers between users. The instructor emphasized that all functionalities will be designed keeping microservice architecture in mind, similar to how companies like Uber and Amazon operate with separate services for different components.
Microservices Architecture and Benefits
The instructor explained the benefits of microservices architecture over monolithic architecture, using examples from Instagram and Uber to demonstrate how individual service outages can affect specific functionalities rather than the entire system. They discussed the importance of the user service in the proposed system and potential solutions for handling outages, including using a cache as a fallback for session data. The instructor also explained the advantages of using Kafka events for communication between services, particularly for handling high volumes of user creation requests, and mentioned that they would continue building the user, wallet, and transaction services in future sessions.
Spring Boot Multi-Module Project Setup
Class discussed creating a major project with multiple modules in Spring Boot. They decided to use Spring for Apache as the main dependency, as it was most suitable for their needs. Class explained how to create different services within a single project by adding modules, and demonstrated this by creating a user service module. They also covered how to set up the project structure, including the pom.xml files for the major project and user service module.
Microservices Architecture With Spring Boot
The instructor demonstrated how to create and run multiple independent microservices in a single project using Maven and Spring Boot. They showed how to set up user service, wallet service, and transaction service, each running on different ports (8000, 9000, and 6000 respectively). The instructor explained that this approach mimics microservice architecture, where services can run independently and be deployed on different servers, similar to how major companies structure their services in a single repository (mono-repo) structure.
Maven Dependency Management in Spring Boot
The discussion focused on optimizing Maven project dependencies in a multi-module Spring Boot application. Class explained how dependencies can be managed at the parent project level, allowing child modules to inherit dependencies, which reduces redundancy and simplifies maintenance. They demonstrated this by showing how to configure a major project with shared dependencies and individual modules with specific dependencies, using Maven clean install to ensure the local repository is updated. The conversation concluded with an understanding of how this monorepo structure aligns with Git and GitHub organization for version control.
User Service Implementation Overview
The instructor discussed the implementation of a user service, including the creation of a user controller and the design of the user model. They decided to include user ID, name, email, phone number, and timestamps for creation and update. The instructor also explained how to handle phone numbers with country codes using a custom class. Sharad suggested adding a country attribute to the phone number class. The instructor demonstrated creating a user service with a repository interface and discussed publishing a Kafka event on user creation. They concluded by mentioning the need to add null pointer checks and validations for the user data.
Kafka Configuration and Implementation Overview
The instructor discussed Kafka configuration and implementation in a user service. They explained how to set up Kafka producer and consumer configurations, including key-value serialization and bootstrap servers. The instructor demonstrated creating a Kafka template and producer factory with appropriate properties, and showed how to publish events from the user service. They emphasized using string serialization for keys to handle cross-language compatibility between Java and Python services.
Kafka Partitioning and Serialization Basics
The instructor explained Kafka's partitioning mechanism, clarifying that while the console producer doesn't allow partition selection, the Java SDK does, though dynamically changing partitions is not recommended. They demonstrated how to publish data to Kafka using a topic name defined in the user service, converting Java objects to strings using an ObjectMapper from the FasterXML Jackson library. The instructor also explained Kafka's built-in serializers and why the string serializer is recommended over Jdk serializer, noting that Redis Jdk Serial library might be an alternative but would need testing for compatibility.
User Service Database Setup Issues
The team discussed issues with a user service application and database setup. They encountered problems determining the recommended JDBC type and resolved it by adding column definitions for phone and contact data. Sharad suggested removing the phone field, but Class explained it was needed for unique constraints. They also discussed adding a nullable false attribute, but Class explained it wouldn't work with their requirements. The team decided to skip some dependencies that weren't working and move forward with the current setup. Class demonstrated that the application was now creating tables in the database and successfully saving user data.
Kafka Producer Resolution Discussion
The team discussed issues with a Kafka producer not receiving responses due to a non-running Kafka server, which was resolved by starting the server. They confirmed that data was being saved to the SQL server before the producer attempted to publish messages. The group also explored how to verify message publication using a console consumer and examined logs to confirm that messages were being stored in the correct partition. They concluded by explaining that the user service publishes all user data, which the wallet service will filter as needed, and planned to discuss adding a consumer in the wallet service in the next session.
Kafka Consumer Groups Overview
The class discussed Kafka consumer groups and offset management, explaining how consumers read messages from partitions and restart from the last read message when they come back online. They explored how to create multiple consumers in the same group and how to view consumer group information through the Kafka console. The instructor agreed to push code for incorporating Redis and database integration into the minor project, which would be covered in the next class session.
